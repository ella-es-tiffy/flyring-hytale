package com.tiffy.flyring;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.ExclusionStrategy;
import com.google.gson.FieldAttributes;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.IOException;

/**
 * ModConfig - Manages mod configuration
 * - Enable/disable recipes
 * - Configure gameplay values (lifesteal percentage, etc.)
 */
public class ModConfig {

    public static class RingEnabled {
        public boolean flyRing = true;
        public boolean fireRing = true;
        public boolean waterRing = true;
        public boolean healRing = true;
        public boolean peacefulRing = true;
        public boolean gaiaMedallion = true;
    }

    public static class GameplayValues {
        public double lifestealPercent = 0.25; // 25% lifesteal
        public boolean nightVisionEnabled = true; // Enable/disable Night Vision listener (Ring + Trigger Item)
        public String nightVisionTriggerItem = "Furniture_Crude_Torch"; // Item needed for Night Vision (with
                                                                        // Peaceful/Heal Ring)
    }

    public static class Config {
        public String _notice = "Illegal Rings v" + BuildInfo.VERSION
                + " - This file is automatically generated and synced. Missing rings or empty bench requirements will be restored on start. Delete this file to fully regenerate defaults.";
        public RingEnabled enabled = new RingEnabled();
        public RingEnabled craftable = new RingEnabled();
        public GameplayValues gameplay = new GameplayValues();
        public boolean debugLogging = false; // Toggle for mod-specific debug logs
        public boolean testserver = false; // Only for testing: Use localhost:9090 instead of production server
        public boolean backpackEnabled = true; // Controls if rings work in backpacks
        public boolean notification = true; // Show update notifications
        public boolean spawnTiffyNpc = true; // Spawn Tiffy merchant NPC in Forgotten Temple (disable if you want to place manually with /npc)
        public boolean noFreePet = false; // If true, no free trial pet is given on first login
        public String freePetMessage = "Thank you for playing Illegal Rings, you are amazing <3 Here's a free Fox companion for {time}!"; // {time} = duration placeholder
        public boolean analyticsEnabled = false; // When OFF: no UUID or IP is sent - player name is always sent for error attribution
        public int configVersion = 0; // Config version for migration tracking
        public List<RecipeOverride> recipeOverrides = new ArrayList<>();
        public LootConfig loot = new LootConfig(); // Ring loot/drop system configuration

        /**
         * Semantic validation - checks for logical errors that GSON might swallow
         */
        public void validate() {
            if (recipeOverrides != null) {
                for (RecipeOverride recipe : recipeOverrides) {
                    if (recipe.targetItemId == null || recipe.targetItemId.trim().isEmpty()) {
                        throw new RuntimeException("Validation Error: Recipe targetItemId is empty or null!");
                    }

                    if (recipe.ingredients != null) {
                        for (Ingredient ing : recipe.ingredients) {
                            if (ing.id == null || ing.id.trim().isEmpty()) {
                                throw new RuntimeException("Validation Error: Ingredient ID is empty in recipe for "
                                        + recipe.targetItemId);
                            }
                            if (ing.amount <= 0) {
                                throw new RuntimeException("Validation Error: Ingredient '" + ing.id
                                        + "' has invalid amount: " + ing.amount);
                            }
                            // Detect suspicious numbers (limit 99k for dev/balancing safety)
                            if (ing.amount > 99999) {
                                throw new RuntimeException("Validation Error: Amount for '" + ing.id
                                        + "' is suspiciously high (limit 99,999). Current: " + ing.amount);
                            }
                        }
                    }
                }
            }

            // Validate Gameplay Values
            if (gameplay == null) {
                throw new RuntimeException("Validation Error: Gameplay section is missing from config!");
            }
            if (gameplay.lifestealPercent < 0 || gameplay.lifestealPercent > 1.0) {
                throw new RuntimeException(
                        "Validation Error: lifestealPercent must be between 0.0 and 1.0 (0% - 100%). Current: "
                                + gameplay.lifestealPercent);
            }
        }
    }

    public static class RecipeOverride {
        public String targetItemId;
        public List<Ingredient> ingredients = new ArrayList<>();
        public List<BenchRequirementConfig> benchRequirements = new ArrayList<>();
    }

    public static class BenchRequirementConfig {
        public String id;
        public String type = "Crafting"; // Matches BenchType.Crafting
        public List<String> categories = new ArrayList<>();
        public int requiredTierLevel = 0;

        public BenchRequirementConfig() {
        }

        public BenchRequirementConfig(String id, String type, String... categories) {
            this.id = id;
            this.type = type;
            if (categories != null) {
                for (String cat : categories) {
                    this.categories.add(cat);
                }
            }
        }
    }

    public static class Ingredient {
        public String id;
        public int amount;

        public Ingredient() {
        }

        public Ingredient(String id, int amount) {
            this.id = id;
            this.amount = amount;
        }
    }

    /**
     * RingLootConfig - Per-ring loot configuration
     */
    public static class RingLootConfig {
        public boolean enabled = true;
        public double directDropRate = 0.5; // 50% chance for direct ring drop
        public String fragmentItem; // e.g. "Ingredient_Crystal_Blue" - drops as bonus loot
        public double fragmentDropRate = 0.5; // 50% chance for crystal drop
        public int fragmentsRequired = 10; // Info only - how many crystals for manual crafting
        public List<String> npcs = new ArrayList<>(); // NPC Role Names that drop this ring

        public RingLootConfig() {
        }

        public RingLootConfig(boolean enabled, double directDropRate, String fragmentItem,
                double fragmentDropRate, int fragmentsRequired, List<String> npcs) {
            this.enabled = enabled;
            this.directDropRate = directDropRate;
            this.fragmentItem = fragmentItem;
            this.fragmentDropRate = fragmentDropRate;
            this.fragmentsRequired = fragmentsRequired;
            this.npcs = npcs != null ? new ArrayList<>(npcs) : new ArrayList<>();
        }
    }

    /**
     * NpcLootEntry - Per-NPC loot configuration (NPC-centric)
     * Same NPC can appear multiple times for different rings.
     */
    public static class NpcLootEntry {
        public String npc;                      // NPC Role Name
        public String ring;                     // Ring type: "fly", "fire", "water", "heal", "peaceful", "gaia"
        public double directDropRate = 0.05;    // Chance for direct ring drop (0.0-1.0)
        public String fragmentItem;             // e.g. "Ingredient_Stud_Iron"
        public double fragmentDropRate = 0.7;   // Chance for fragment drop (0.0-1.0)
        public int fragmentsRequired = 10;      // Info only - how many fragments for manual crafting

        public NpcLootEntry() {}

        public NpcLootEntry(String npc, String ring, double directDropRate, String fragmentItem,
                double fragmentDropRate, int fragmentsRequired) {
            this.npc = npc;
            this.ring = ring;
            this.directDropRate = directDropRate;
            this.fragmentItem = fragmentItem;
            this.fragmentDropRate = fragmentDropRate;
            this.fragmentsRequired = fragmentsRequired;
        }
    }

    /**
     * LootConfig - Global loot system configuration
     */
    public static class LootConfig {
        public boolean enabled = true;
        public Map<String, RingLootConfig> rings = null; // Deprecated: old ring-centric format, kept for migration
        public List<NpcLootEntry> npcs = new ArrayList<>();

        public LootConfig() {
            // Default NPC loot entries - 5% ring drop, 70% studs
            npcs.add(new NpcLootEntry("Horse_Skeleton", "fly", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Wolf_Black", "fly", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Skeleton_Burnt_Soldier", "fire", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Skeleton_Burnt_Archer", "fire", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Zombie_Frost", "water", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Golem_Crystal_Frost", "water", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Skeleton_Frost_Mage", "heal", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Skeleton_Frost_Archmage", "heal", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Goblin_Hermit", "peaceful", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Trork_Shaman", "peaceful", 0.05, "Ingredient_Stud_Iron", 0.7, 10));
            npcs.add(new NpcLootEntry("Wraith", "gaia", 0.05, null, 0.0, 0));
            npcs.add(new NpcLootEntry("Golem_Crystal_Flame", "gaia", 0.05, null, 0.0, 0));
        }

        /**
         * Migrate old ring-centric format to NPC-centric list.
         * Returns true if migration was performed.
         */
        public boolean migrateFromRings() {
            if (rings == null || rings.isEmpty()) return false;

            npcs = new ArrayList<>();
            for (Map.Entry<String, RingLootConfig> entry : rings.entrySet()) {
                String ringType = entry.getKey();
                RingLootConfig rc = entry.getValue();
                if (!rc.enabled) continue;
                for (String npcName : rc.npcs) {
                    npcs.add(new NpcLootEntry(
                        npcName, ringType, rc.directDropRate, rc.fragmentItem,
                        rc.fragmentDropRate, rc.fragmentsRequired
                    ));
                }
            }
            rings = null;
            System.out.println("[ModConfig] Migrated " + npcs.size() + " loot entries from ring-centric to NPC-centric format");
            return true;
        }
    }

    private static final String CONFIG_DIR = "mods/tiffy-illegalrings";
    private static final String OLD_CONFIG_DIR = "mods/tiffy"; // Migration
    private static final String CONFIG_FILE = "config.json";
    private static Config instance;
    private static File gameDir;
    public static String VERSION = BuildInfo.VERSION;

    public static ConfigLoadData loadWithStatus(File gameDirectory) {
        gameDir = gameDirectory;
        migrateOldConfig(gameDirectory);

        if (instance != null) {
            // Already loaded - return OK status
            return new ConfigLoadData(ConfigLoadResult.OK, instance, "", null, 0);
        }

        File configDir = new File(gameDirectory, CONFIG_DIR);
        File configFile = new File(configDir, CONFIG_FILE);

        Gson gson = new GsonBuilder().setPrettyPrinting().create();

        String rawJson = "";
        ConfigLoadResult status = ConfigLoadResult.OK;
        String errorMessage = null;

        // Check if config file exists
        if (!configFile.exists()) {
            // CASE 1: CONFIG_MISSING
            AnalyticsClient.reportConfigCheckMissing(VERSION);

            status = ConfigLoadResult.MISSING;
            instance = new Config();
            instance.configVersion = BuildInfo.CONFIG_VERSION;
            syncDefaults(instance);
            save(gameDirectory);

            // Read back the created config for analytics
            try (java.io.FileReader reader = new java.io.FileReader(configFile)) {
                StringBuilder sb = new StringBuilder();
                int ch;
                while ((ch = reader.read()) != -1) {
                    sb.append((char) ch);
                }
                rawJson = sb.toString();
            } catch (IOException e) {
                rawJson = "ERROR_READING_CREATED_CONFIG";
            }

            AnalyticsClient.reportConfigCreated(VERSION, rawJson);
            return new ConfigLoadData(status, instance, rawJson, null, 0);
        }

        // Config file exists - try to load it
        try (java.io.FileReader reader = new java.io.FileReader(configFile)) {
            // Read raw JSON first for analytics
            StringBuilder sb = new StringBuilder();
            int ch;
            while ((ch = reader.read()) != -1) {
                sb.append((char) ch);
            }
            rawJson = sb.toString();
        } catch (IOException e) {
            rawJson = "ERROR_READING_FILE";
        }

        // Try to parse the JSON
        try (java.io.FileReader reader = new java.io.FileReader(configFile)) {
            instance = gson.fromJson(reader, Config.class);
            if (instance == null)
                instance = new Config();

            // Always update notice to current version
            String currentNotice = "Illegal Rings v" + BuildInfo.VERSION
                    + " - This file is automatically generated and synced. Missing rings or empty bench requirements will be restored on start. Delete this file to fully regenerate defaults.";
            if (!currentNotice.equals(instance._notice)) {
                instance._notice = currentNotice;
            }

            // Check for version mismatch
            int oldVersion = instance.configVersion;
            if (instance.configVersion < BuildInfo.CONFIG_VERSION) {
                // CASE 3: CONFIG_VERSION_MISMATCH
                AnalyticsClient.reportConfigCheckVersionMismatch(VERSION, oldVersion, BuildInfo.CONFIG_VERSION);

                status = ConfigLoadResult.VERSION_MISMATCH;
                System.out.println("[ModConfig] Migrating config version: " + instance.configVersion + " -> "
                        + BuildInfo.CONFIG_VERSION);
                instance.configVersion = BuildInfo.CONFIG_VERSION;
                instance._notice = currentNotice;
                syncDefaults(instance);
                save(gameDirectory);

                // Read back the renewed config
                try (java.io.FileReader newReader = new java.io.FileReader(configFile)) {
                    StringBuilder sb = new StringBuilder();
                    int ch;
                    while ((ch = newReader.read()) != -1) {
                        sb.append((char) ch);
                    }
                    rawJson = sb.toString();
                } catch (IOException e) {
                    // Keep old rawJson
                }

                AnalyticsClient.reportConfigRenewed(VERSION, rawJson);
            } else {
                // CASE 4: CONFIG_OK
                AnalyticsClient.reportConfigCheckOk(VERSION);

                // Check if defaults need syncing (missing rings/bench requirements)
                if (syncDefaults(instance)) {
                    save(gameDirectory);
                }
                status = ConfigLoadResult.OK;
                AnalyticsClient.reportConfigOk(VERSION, rawJson);
            }

            // Semantic validation
            if (instance != null) {
                instance.validate();
            }

            return new ConfigLoadData(status, instance, rawJson, null, oldVersion);

        } catch (com.google.gson.JsonSyntaxException e) {
            // CASE 2: CONFIG_SYNTAX_ERROR
            AnalyticsClient.reportConfigCheckSyntaxError(VERSION, e.getMessage(), rawJson);

            status = ConfigLoadResult.SYNTAX_ERROR;
            errorMessage = e.getMessage();
            System.err.println("[ModConfig] JSON Syntax Error: " + e.getMessage());

            // Use defaults
            instance = new Config();
            instance.configVersion = BuildInfo.CONFIG_VERSION;
            syncDefaults(instance);
            // Don't overwrite broken config - user might want to fix it

            AnalyticsClient.reportConfigSyntaxError(VERSION, errorMessage, rawJson);
            return new ConfigLoadData(status, instance, rawJson, errorMessage, 0);

        } catch (Exception e) {
            // CASE 2: CONFIG_SYNTAX_ERROR (other parse errors)
            AnalyticsClient.reportConfigCheckSyntaxError(VERSION, e.getMessage(), rawJson);

            status = ConfigLoadResult.SYNTAX_ERROR;
            errorMessage = e.getMessage();
            System.err.println("[ModConfig] Failed to load config: " + e.getMessage());

            // Use defaults
            instance = new Config();
            instance.configVersion = BuildInfo.CONFIG_VERSION;
            syncDefaults(instance);

            AnalyticsClient.reportConfigSyntaxError(VERSION, errorMessage, rawJson);
            return new ConfigLoadData(status, instance, rawJson, errorMessage, 0);
        }
    }

    /**
     * Legacy load method - kept for compatibility
     */
    public static Config load(File gameDirectory) {
        ConfigLoadData result = loadWithStatus(gameDirectory);
        return result.config;
    }

    private static boolean syncDefaults(Config config) {
        boolean modified = false;

        // Migrate old ring-centric loot to NPC-centric
        if (config.loot != null) {
            modified |= config.loot.migrateFromRings();
        }

        if (config.recipeOverrides == null) {
            config.recipeOverrides = new ArrayList<>();
            modified = true;
        }

        modified |= ensureRingInConfig(config, "Jewelry_Fly_Ring",
                new Ingredient("Ingredient_Bar_Iron", 300),
                new Ingredient("Ingredient_Life_Essence", 100),
                new Ingredient("Ingredient_Bar_Thorium", 10),
                new Ingredient("Ingredient_Feathers_Light", 1));

        modified |= ensureRingInConfig(config, "Jewelry_Fire_Ring",
                new Ingredient("Ingredient_Bar_Iron", 100),
                new Ingredient("Ingredient_Fire_Essence", 100),
                new Ingredient("Ingredient_Bar_Gold", 10),
                new Ingredient("Ingredient_Bar_Adamantite", 1));

        modified |= ensureRingInConfig(config, "Jewelry_Water_Ring",
                new Ingredient("Ingredient_Bar_Iron", 100),
                new Ingredient("Ingredient_Life_Essence", 25),
                new Ingredient("Ingredient_Stick", 50),
                new Ingredient("Ingredient_Crystal_Blue", 1));

        modified |= ensureRingInConfig(config, "Jewelry_Heal_Ring",
                new Ingredient("Ingredient_Bar_Iron", 300),
                new Ingredient("Ingredient_Life_Essence", 100),
                new Ingredient("Ingredient_Bar_Thorium", 30),
                new Ingredient("Ingredient_Bar_Cobalt", 30));

        modified |= ensureRingInConfig(config, "Jewelry_Peacefull_Ring",
                new Ingredient("Rock_Stone_Cobble", 200),
                new Ingredient("Ingredient_Life_Essence", 10),
                new Ingredient("Ingredient_Fibre", 100),
                new Ingredient("Plant_Fruit_Apple", 10));

        modified |= ensureRingInConfig(config, "Jewelry_Gaia_Medallion",
                new Ingredient("Jewelry_Fly_Ring", 1),
                new Ingredient("Jewelry_Fire_Ring", 1),
                new Ingredient("Jewelry_Water_Ring", 1),
                new Ingredient("Jewelry_Heal_Ring", 1),
                new Ingredient("Jewelry_Peacefull_Ring", 1));

        return modified;
    }

    private static boolean ensureRingInConfig(Config config, String ringId, Ingredient... defaultIngredients) {
        boolean modified = false;
        RecipeOverride found = null;

        for (RecipeOverride ro : config.recipeOverrides) {
            if (ro.targetItemId.equals(ringId)) {
                found = ro;
                break;
            }
        }

        if (found == null) {
            RecipeOverride ro = createOverride(ringId, defaultIngredients);
            ro.benchRequirements.add(new BenchRequirementConfig("Workbench", "Crafting", "Workbench_Tinkering"));
            config.recipeOverrides.add(ro);
            return true;
        }

        if (found.benchRequirements == null || found.benchRequirements.isEmpty()) {
            if (found.benchRequirements == null)
                found.benchRequirements = new ArrayList<>();
            found.benchRequirements.add(new BenchRequirementConfig("Workbench", "Crafting", "Workbench_Tinkering"));
            modified = true;
        }

        return modified;
    }

    private static RecipeOverride createOverride(String id, Ingredient... ingredients) {
        RecipeOverride ro = new RecipeOverride();
        ro.targetItemId = id;
        for (Ingredient ing : ingredients) {
            ro.ingredients.add(ing);
        }
        return ro;
    }

    public static void save(File gameDirectory) {
        if (instance == null)
            return;

        // Clean empty ingredients before saving
        if (instance.recipeOverrides != null) {
            for (RecipeOverride ro : instance.recipeOverrides) {
                if (ro.ingredients != null) {
                    ro.ingredients.removeIf(ing -> ing.id == null || ing.id.trim().isEmpty());
                }
            }
        }

        File configDir = new File(gameDirectory, CONFIG_DIR);
        File configFile = new File(configDir, CONFIG_FILE);

        Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .setExclusionStrategies(new ExclusionStrategy() {
                    @Override
                    public boolean shouldSkipField(FieldAttributes f) {
                        return f.getName().equals("testserver") || f.getName().equals("rings");
                    }

                    @Override
                    public boolean shouldSkipClass(Class<?> clazz) {
                        return false;
                    }
                })
                .create();

        try {
            if (!configDir.exists())
                configDir.mkdirs();
            try (java.io.FileWriter writer = new java.io.FileWriter(configFile)) {
                gson.toJson(instance, writer);
            }
        } catch (IOException e) {
            System.err.println("[ModConfig] Failed to save config: " + e.getMessage());
        }
    }

    public static void save() {
        if (gameDir != null) save(gameDir);
    }

    public static Config getInstance() {
        return instance;
    }

    private static void migrateOldConfig(File gameDirectory) {
        File oldConfigDir = new File(gameDirectory, OLD_CONFIG_DIR);
        File oldConfigFile = new File(oldConfigDir, CONFIG_FILE);

        if (!oldConfigFile.exists())
            return;

        File newConfigDir = new File(gameDirectory, CONFIG_DIR);
        File newConfigFile = new File(newConfigDir, CONFIG_FILE);

        if (newConfigFile.exists())
            return;

        try {
            if (!newConfigDir.exists())
                newConfigDir.mkdirs();

            java.nio.file.Files.copy(
                    oldConfigFile.toPath(),
                    newConfigFile.toPath(),
                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);

            System.out.println("[ModConfig] Migrated config to " + CONFIG_DIR);
        } catch (IOException e) {
            System.err.println("[ModConfig] Migration failed: " + e.getMessage());
        }
    }
}
